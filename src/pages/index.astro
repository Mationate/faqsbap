---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import Hero from '../components/Hero.astro';
import CategoryNav from '../components/CategoryNav.astro';
import FaqSection from '../components/FaqSection.astro';
import Footer from '../components/Footer.astro';
import { faqData } from '../data/faq';

const totalQuestions = faqData.reduce((sum, cat) => sum + cat.questions.length, 0);
const officialCount = faqData.reduce(
  (sum, cat) => sum + cat.questions.filter(q => q.isOfficial).length,
  0
);
---
<Layout title="Preguntas Frecuentes — Traspaso CONAF a SBAP">
  <Header />
  <Hero />

  <!-- Stats bar -->
  <div class="w-full bg-stone-50 border-b border-gray-200">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3 sm:py-4">
      <div class="grid grid-cols-2 sm:flex sm:flex-wrap sm:justify-center gap-3 sm:gap-6 text-xs sm:text-sm text-gray-500">
        <div class="stat-item flex items-center gap-2">
          <span class="w-2 h-2 rounded-full bg-bosque-500 shrink-0"></span>
          <span><strong class="text-gray-800">{faqData.length}</strong> categorías</span>
        </div>
        <div class="stat-item flex items-center gap-2">
          <span class="w-2 h-2 rounded-full bg-tierra-500 shrink-0"></span>
          <span><strong class="text-gray-800">{totalQuestions}</strong> preguntas</span>
        </div>
        <div class="stat-item flex items-center gap-2">
          <span class="w-2 h-2 rounded-full bg-cielo-400 shrink-0"></span>
          <span><strong class="text-gray-800">{officialCount}</strong> resp. oficiales</span>
        </div>
        <div class="stat-item flex items-center gap-2">
          <span class="w-2 h-2 rounded-full bg-purple-400 shrink-0"></span>
          <span><strong class="text-gray-800">16</strong> regiones</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Mobile category nav (outside main to avoid sticky + overflow conflict on iOS) -->
  <CategoryNav categories={faqData} mobile />

  <!-- Main content -->
  <main id="preguntas" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-10">
    <div class="lg:grid lg:grid-cols-[260px_minmax(0,1fr)] lg:gap-10">
      <CategoryNav categories={faqData} />

      <div class="space-y-16 sm:space-y-12 min-w-0" id="faq-content">
        <!-- Empty state -->
        <div id="empty-state" class="hidden text-center py-16">
          <div class="w-16 h-16 mx-auto mb-4 text-gray-300">
            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path d="m21 21l-4.34-4.34"/><circle cx="11" cy="11" r="8"/></svg>
          </div>
          <h3 class="text-xl font-bold text-gray-700 mb-2">
            No se encontraron resultados
          </h3>
          <p class="text-gray-500 max-w-md mx-auto">
            Intenta con otros términos de búsqueda. Puedes buscar por tema, región o artículo de ley.
          </p>
          <button
            id="clear-search-btn"
            class="mt-4 px-4 py-2 rounded-lg bg-bosque-500 text-white text-sm font-medium hover:bg-bosque-600 transition-colors"
          >
            Limpiar búsqueda
          </button>
        </div>

        {faqData.map(category => (
          <FaqSection category={category} />
        ))}
      </div>
    </div>
  </main>

  <Footer />
</Layout>

<script>
  // ── Helpers ──
  function normalize(str: string): string {
    return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
  }

  function debounce<T extends (...args: unknown[]) => void>(fn: T, ms: number): T {
    let timer: ReturnType<typeof setTimeout>;
    return ((...args: unknown[]) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), ms);
    }) as T;
  }

  // ── DOM refs ──
  const searchInput = document.getElementById('faq-search') as HTMLInputElement;
  const searchIcon = document.getElementById('search-icon') as SVGElement;
  const searchSpinner = document.getElementById('search-spinner') as HTMLDivElement;
  const clearBtn = document.getElementById('search-clear') as HTMLButtonElement;
  const clearSearchBtn = document.getElementById('clear-search-btn') as HTMLButtonElement;
  const searchStatus = document.getElementById('search-status') as HTMLDivElement;
  const emptyState = document.getElementById('empty-state') as HTMLDivElement;
  const faqItems = document.querySelectorAll<HTMLDetailsElement>('.faq-item');
  const faqSections = document.querySelectorAll<HTMLElement>('.faq-category');
  const navLinks = document.querySelectorAll<HTMLAnchorElement>('[data-nav-category]');

  // ── Accordion animation ──
  const ANIM_DURATION = 300;
  const ANIM_EASING = 'cubic-bezier(0.4, 0, 0.2, 1)';

  faqItems.forEach(details => {
    const summary = details.querySelector('summary')!;
    const answer = details.querySelector('.faq-answer') as HTMLElement;
    let animation: Animation | null = null;

    summary.addEventListener('click', (e) => {
      e.preventDefault();

      // Cancel any running animation
      if (animation) animation.cancel();

      if (details.open) {
        // ── Closing ──
        const startHeight = answer.offsetHeight;
        animation = answer.animate(
          [
            { height: `${startHeight}px`, opacity: 1 },
            { height: '0px', opacity: 0 },
          ],
          { duration: ANIM_DURATION, easing: ANIM_EASING }
        );
        animation.onfinish = () => {
          details.open = false;
          animation = null;
        };
      } else {
        // ── Opening ──
        details.open = true;
        const endHeight = answer.offsetHeight;
        animation = answer.animate(
          [
            { height: '0px', opacity: 0 },
            { height: `${endHeight}px`, opacity: 1 },
          ],
          { duration: ANIM_DURATION, easing: ANIM_EASING }
        );
        animation.onfinish = () => {
          animation = null;
        };
      }
    });
  });

  // ── Search spinner ──
  function showSpinner() {
    searchIcon.classList.add('hidden');
    searchSpinner.classList.remove('hidden');
  }

  function hideSpinner() {
    searchSpinner.classList.add('hidden');
    searchIcon.classList.remove('hidden');
  }

  // ── Search ──
  function performSearch(query: string) {
    const normalizedQuery = normalize(query.trim());
    const isSearching = normalizedQuery.length > 0;

    clearBtn.classList.toggle('hidden', !isSearching);

    let visibleCount = 0;

    faqItems.forEach(item => {
      if (!isSearching) {
        item.classList.remove('hidden');
        item.open = false;
        visibleCount++;
        return;
      }

      const questionText = normalize(
        item.querySelector('.faq-question-text')?.textContent ?? ''
      );
      const answerText = normalize(
        item.querySelector('.faq-answer-text')?.textContent ?? ''
      );

      const matches = questionText.includes(normalizedQuery) || answerText.includes(normalizedQuery);

      item.classList.toggle('hidden', !matches);
      if (matches) {
        item.open = true;
        visibleCount++;
      }
    });

    // Show/hide sections based on visible items
    faqSections.forEach(section => {
      const visibleItems = section.querySelectorAll('.faq-item:not(.hidden)');
      section.classList.toggle('hidden', visibleItems.length === 0);
    });

    // Search status
    const searchStatusText = document.getElementById('search-status-text')!;
    if (isSearching && visibleCount > 0) {
      searchStatusText.textContent = `${visibleCount} ${visibleCount === 1 ? 'resultado' : 'resultados'} para "${query.trim()}"`;
      searchStatus.classList.remove('hidden');
    } else {
      searchStatus.classList.add('hidden');
    }

    // Empty state
    emptyState.classList.toggle('hidden', visibleCount > 0 || !isSearching);

    // Scroll to first visible result
    if (isSearching && visibleCount > 0) {
      const firstMatch = document.querySelector('.faq-item:not(.hidden)');
      if (firstMatch) {
        setTimeout(() => {
          firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 50);
      }
    }

    // Done searching — hide spinner
    hideSpinner();
  }

  const debouncedSearch = debounce(() => {
    performSearch(searchInput.value);
  }, 300);

  searchInput.addEventListener('input', () => {
    // Show spinner immediately on keystroke (search is debounced)
    if (searchInput.value.trim().length > 0) {
      showSpinner();
    } else {
      hideSpinner();
    }
    debouncedSearch();
  });

  clearBtn.addEventListener('click', () => {
    searchInput.value = '';
    hideSpinner();
    performSearch('');
    searchInput.focus();
  });

  clearSearchBtn.addEventListener('click', () => {
    searchInput.value = '';
    hideSpinner();
    performSearch('');
    searchInput.focus();
  });

  // ── Scroll-triggered animations ──
  const animObserver = new IntersectionObserver(
    entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('is-visible');
        }
      });
    },
    { rootMargin: '0px 0px -80px 0px', threshold: 0.1 }
  );

  faqSections.forEach(section => {
    section.classList.add('animate-fade-in-up');
    animObserver.observe(section);
  });

  // ── Scroll spy ──
  const spyObserver = new IntersectionObserver(
    entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const id = entry.target.getAttribute('data-category');
          if (id) setActiveNav(id);
        }
      });
    },
    { rootMargin: '-100px 0px -60% 0px', threshold: 0 }
  );

  faqSections.forEach(section => spyObserver.observe(section));

  function setActiveNav(categoryId: string) {
    navLinks.forEach(link => {
      const isActive = link.getAttribute('data-nav-category') === categoryId;
      link.classList.toggle('active', isActive);

      // Scroll mobile nav pill into view (using scrollLeft to avoid iOS vertical scroll hijack)
      if (isActive && link.closest('#nav-mobile')) {
        const container = document.getElementById('nav-mobile');
        if (container) {
          const pillLeft = (link as HTMLElement).offsetLeft;
          const pillWidth = (link as HTMLElement).offsetWidth;
          const containerWidth = container.offsetWidth;
          const targetScroll = pillLeft - (containerWidth / 2) + (pillWidth / 2);
          container.scrollTo({ left: targetScroll, behavior: 'smooth' });
        }
      }
    });

    // Update URL hash without scrolling
    if (history.replaceState) {
      history.replaceState(null, '', `#${categoryId}`);
    }
  }

  // ── Hash navigation ──
  function handleHash() {
    const hash = window.location.hash.slice(1);
    if (hash) {
      const target = document.getElementById(hash);
      if (target) {
        setTimeout(() => {
          target.scrollIntoView({ behavior: 'smooth' });
        }, 100);
      }
    }
  }

  handleHash();
  window.addEventListener('hashchange', handleHash);

  // ── Smooth scroll for nav links ──
  navLinks.forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const categoryId = link.getAttribute('data-nav-category');
      if (categoryId) {
        const target = document.getElementById(categoryId);
        if (target) {
          // Clear search if active
          if (searchInput.value) {
            searchInput.value = '';
            hideSpinner();
            performSearch('');
          }
          target.scrollIntoView({ behavior: 'smooth' });
        }
      }
    });
  });
</script>
